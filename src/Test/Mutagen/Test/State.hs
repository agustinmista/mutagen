{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}

-- | Internal Mutagen testing state and state manipulation functions
module Test.Mutagen.Test.State
  ( -- * Mutagen internal state
    MutagenState (..)
  , initMutagenState

    -- * State modifiers
  , setExpect
  , setNextSeed
  , setCurrentGenSize
  , setAutoResetAfter
  , setRandomMutations
  , setPassedQueue
  , updatePassedQueue
  , setDiscardedQueue
  , updateDiscardedQueue
  , setFragmentStore
  , updateFragmentStore
  , incNumTraceLogResets
  , incNumPassed
  , incNumDiscarded
  , incNumGenerated
  , incNumMutatedFromPassed
  , incNumMutatedFromDiscarded
  , incNumInteresting
  , incNumBoring
  , incNumTestsSinceLastInteresting
  , incMutantKindCounter
  , resetNumTestsSinceLastInteresting

    -- * State-related utilities
  , timedOut
  , computeSize
  )
where

import Data.Time.Clock.POSIX (getPOSIXTime)
import Test.Mutagen.Config (Config (..), DebugMode (..))
import Test.Mutagen.Fragment
  ( FragmentStore
  , FragmentTypeFilter
  , emptyFragmentStore
  , storeFragments
  )
import Test.Mutagen.Mutant (MutantKind (..))
import Test.Mutagen.Mutation (MutationOrder)
import Test.Mutagen.Property (Args (..), Prop, Property (..))
import Test.Mutagen.Test.Queue (MutationQueue, emptyMutationQueue)
import Test.Mutagen.Tracer.Metadata (loadTracerMetadata, numTracingNodes)
import Test.Mutagen.Tracer.Store
  ( STraceType
  , TraceStoreImpl (..)
  , withTraceType
  )
import Test.QuickCheck.Gen (Gen)
import Test.QuickCheck.Random (QCGen, newQCGen)

{-------------------------------------------------------------------------------
-- * Mutagen internal state
-------------------------------------------------------------------------------}

-- | Internal testing state
data MutagenState
  = forall trace.
  (TraceStoreImpl trace) =>
  MutagenState
  { stMaxSuccess :: !Int
  -- ^ Mirrored from 'Config.maxSuccess'
  , stMaxDiscardRatio :: !Int
  -- ^ Mirrored from 'Config.maxDiscardRatio'
  , stTimeout :: !(Maybe Integer)
  -- ^ Mirrored from 'Config.timeout'
  , stExpect :: Bool
  -- ^ Mirrored from 'Config.expect'
  , stMaxGenSize :: !Int
  -- ^ Mirrored from 'Config.maxGenSize'
  , stRandomMutations :: !Int
  -- ^ Mirrored from 'Config.randomMutations'
  , stMutationLimit :: !Int
  -- ^ Mirrored from 'Config.mutationLimit'
  , stAutoResetAfter :: !(Maybe Int)
  -- ^ Mirrored from 'Config.autoResetAfter'
  , stUseLazyPrunning :: !Bool
  -- ^ Mirrored from 'Config.useLazyPrunning'
  , stMutationOrder :: !MutationOrder
  -- ^ Mirrored from 'Config.mutationOrder'
  , stRandomFragments :: !Int
  -- ^ Mirrored from 'Config.randomFragments'
  , stUseFragments :: !Bool
  -- ^ Mirrored from 'Config.useFragments'
  , stFilterFragments :: !FragmentTypeFilter
  -- ^ Mirrored from 'Config.filterFragments'
  , stMaxTraceLength :: !(Maybe Int)
  -- ^ Mirrored from 'Config.maxTraceLength'
  , stChatty :: !Bool
  -- ^ Mirrored from 'Config.chatty'
  , stDebug :: !DebugMode
  -- ^ Mirrored from 'Config.debug'
  , stNextSeed :: !QCGen
  -- ^ Next seed to be when generating random values
  , stArgsGen :: !(Gen Args)
  -- ^ Random generator for test case inputs
  , stArgsRunner :: !(Args -> Prop)
  -- ^ Test case runner
  , stNumTracingNodes :: !Int
  -- ^ Number of trace nodes generated by the tracer plugin
  , stTraceType :: !(STraceType trace)
  -- ^ Tracing type being used
  , stPassedTraceLog :: !(TraceStore trace)
  -- ^ Trace store for passed test cases
  , stDiscardedTraceLog :: !(TraceStore trace)
  -- ^ Trace store for discarded test cases
  , stPassedQueue :: !MutationQueue
  -- ^ Mutation queue derived from passed test cases
  , stDiscardedQueue :: !MutationQueue
  -- ^ Mutation queue derived from discarded test cases
  , stFragmentStore :: !FragmentStore
  -- ^ Stored fragments for fragment-based mutation
  , stStartTime :: !Integer
  -- ^ Timestamp when testing started
  , stCurrentGenSize :: !Int
  -- ^ Size of the current randomly generated test case
  , stNumGenerated :: !Int
  -- ^ Number of generated test cases
  , stNumMutatedFromPassed :: !Int
  -- ^ Number of test cases mutated from passed test cases
  , stNumMutatedFromDiscarded :: !Int
  -- ^ Number of test cases mutated from discarded test cases
  , stNumPureMutants :: !Int
  -- ^ Number of pure mutants generated
  , stNumRandMutants :: !Int
  -- ^ Number of random mutants generated
  , stNumFragMutants :: !Int
  -- ^ Number of fragment mutants generated
  , stNumPassed :: !Int
  -- ^ Number of passed test cases
  , stNumDiscarded :: !Int
  -- ^ Number of discarded test cases
  , stNumInteresting :: !Int
  -- ^ Number of interesting test cases
  , stNumBoring :: !Int
  -- ^ Number of boring test cases
  , stNumTestsSinceLastInteresting :: !Int
  -- ^ Number of test cases since the last interesting one
  , stNumTraceLogResets :: !Int
  -- ^ Number of times the trace logs have been reset
  }

-- | Initialize the internal state
initMutagenState :: Config -> Property -> IO MutagenState
initMutagenState cfg (Property gen argsRunner) = do
  -- Start timestamp
  now <- round <$> getPOSIXTime
  -- Initialize random generator
  rng <- newQCGen
  -- Load the metadata generated
  tracingNodes <- numTracingNodes <$> loadTracerMetadata
  -- If enabled, initialize the fragment store using the provided examples
  let fragmentStore
        | useFragments cfg = fragmentStoreFromExamples (examples cfg)
        | otherwise = emptyFragmentStore
  -- Reify the selected trace store implementation
  withTraceType (traceType cfg) $ \(sTraceType :: STraceType trace) -> do
    -- Initialize empty trace stores for passed and discarded test cases
    passedTraceStore <- newTraceStore @trace tracingNodes
    discardedTraceStore <- newTraceStore @trace tracingNodes
    -- Put it all together
    return
      MutagenState
        { -- From config
          stMaxSuccess = maxSuccess cfg
        , stMaxDiscardRatio = maxDiscardRatio cfg
        , stTimeout = timeout cfg
        , stExpect = expect cfg
        , stMaxGenSize = maxGenSize cfg
        , stRandomMutations = randomMutations cfg
        , stRandomFragments = randomFragments cfg
        , stMutationLimit = maybe (maxGenSize cfg) id (mutationLimit cfg)
        , stAutoResetAfter = autoResetAfter cfg
        , stUseLazyPrunning = useLazyPrunning cfg
        , stMutationOrder = mutationOrder cfg
        , stUseFragments = useFragments cfg
        , stFilterFragments = filterFragments cfg
        , stMaxTraceLength = maxTraceLength cfg
        , stChatty = chatty cfg || debug cfg /= NoDebug
        , stDebug = debug cfg
        , -- Internal
          stNextSeed = rng
        , stArgsGen = gen
        , stArgsRunner = argsRunner
        , stNumTracingNodes = tracingNodes
        , stTraceType = sTraceType
        , stPassedTraceLog = passedTraceStore
        , stDiscardedTraceLog = discardedTraceStore
        , stPassedQueue = emptyMutationQueue
        , stDiscardedQueue = emptyMutationQueue
        , stFragmentStore = fragmentStore
        , stStartTime = now
        , stCurrentGenSize = 0
        , stNumGenerated = 0
        , stNumMutatedFromPassed = 0
        , stNumMutatedFromDiscarded = 0
        , stNumPureMutants = 0
        , stNumRandMutants = 0
        , stNumFragMutants = 0
        , stNumPassed = 0
        , stNumDiscarded = 0
        , stNumInteresting = 0
        , stNumBoring = 0
        , stNumTestsSinceLastInteresting = 0
        , stNumTraceLogResets = 0
        }
  where
    fragmentStoreFromExamples =
      foldr
        (storeFragments (filterFragments cfg))
        emptyFragmentStore

{-------------------------------------------------------------------------------
-- * State modifiers
-------------------------------------------------------------------------------}

-- ** Setters

setExpect :: Bool -> MutagenState -> MutagenState
setExpect val st =
  st{stExpect = val}

setNextSeed :: QCGen -> MutagenState -> MutagenState
setNextSeed val st =
  st{stNextSeed = val}

setCurrentGenSize :: Int -> MutagenState -> MutagenState
setCurrentGenSize val st =
  st{stCurrentGenSize = val}

setAutoResetAfter :: Maybe Int -> MutagenState -> MutagenState
setAutoResetAfter val st =
  st{stAutoResetAfter = val}

setRandomMutations :: Int -> MutagenState -> MutagenState
setRandomMutations val st =
  st{stRandomMutations = val}

setPassedQueue :: MutationQueue -> MutagenState -> MutagenState
setPassedQueue val st =
  st{stPassedQueue = val}

updatePassedQueue :: (MutationQueue -> MutationQueue) -> MutagenState -> MutagenState
updatePassedQueue f st =
  st{stPassedQueue = f (stPassedQueue st)}

setDiscardedQueue :: MutationQueue -> MutagenState -> MutagenState
setDiscardedQueue val st =
  st{stDiscardedQueue = val}

updateDiscardedQueue :: (MutationQueue -> MutationQueue) -> MutagenState -> MutagenState
updateDiscardedQueue f st =
  st{stDiscardedQueue = f (stDiscardedQueue st)}

setFragmentStore :: FragmentStore -> MutagenState -> MutagenState
setFragmentStore val st =
  st{stFragmentStore = val}

updateFragmentStore :: (FragmentStore -> FragmentStore) -> MutagenState -> MutagenState
updateFragmentStore f st =
  st{stFragmentStore = f (stFragmentStore st)}

-- ** Incrementers

incNumTraceLogResets :: MutagenState -> MutagenState
incNumTraceLogResets st =
  st{stNumTraceLogResets = stNumTraceLogResets st + 1}

incNumPassed :: MutagenState -> MutagenState
incNumPassed st =
  st{stNumPassed = stNumPassed st + 1}

incNumDiscarded :: MutagenState -> MutagenState
incNumDiscarded st =
  st{stNumDiscarded = stNumDiscarded st + 1}

incNumGenerated :: MutagenState -> MutagenState
incNumGenerated st =
  st{stNumGenerated = stNumGenerated st + 1}

incNumMutatedFromPassed :: MutagenState -> MutagenState
incNumMutatedFromPassed st =
  st{stNumMutatedFromPassed = stNumMutatedFromPassed st + 1}

incNumMutatedFromDiscarded :: MutagenState -> MutagenState
incNumMutatedFromDiscarded st =
  st{stNumMutatedFromDiscarded = stNumMutatedFromDiscarded st + 1}

incNumInteresting :: MutagenState -> MutagenState
incNumInteresting st =
  st{stNumInteresting = stNumInteresting st + 1}

incNumBoring :: MutagenState -> MutagenState
incNumBoring st =
  st{stNumBoring = stNumBoring st + 1}

incNumTestsSinceLastInteresting :: MutagenState -> MutagenState
incNumTestsSinceLastInteresting st =
  st{stNumTestsSinceLastInteresting = stNumTestsSinceLastInteresting st + 1}

incMutantKindCounter :: MutantKind -> MutagenState -> MutagenState
incMutantKindCounter kind st =
  case kind of
    PureMutant -> st{stNumPureMutants = stNumPureMutants st + 1}
    RandMutant -> st{stNumRandMutants = stNumRandMutants st + 1}
    FragMutant -> st{stNumFragMutants = stNumFragMutants st + 1}

-- ** Resetters

resetNumTestsSinceLastInteresting :: MutagenState -> MutagenState
resetNumTestsSinceLastInteresting st =
  st{stNumTestsSinceLastInteresting = 0}

{-------------------------------------------------------------------------------
-- * State-related utilities
-------------------------------------------------------------------------------}

-- Check whether the timeout has passed
timedOut :: MutagenState -> IO Bool
timedOut st
  | Just s <- stTimeout st = do
      now <- round <$> getPOSIXTime
      return (now >= stStartTime st + s)
  | otherwise = return False

-- Compute the size of the next randomly generated value
--
-- NOTE : This function mimics QuickCheck's size computation strategy
computeSize :: MutagenState -> Int
computeSize st
  | stNumPassed st `roundTo` stMaxGenSize st + stMaxGenSize st <= stMaxSuccess st
      || stNumPassed st >= stMaxSuccess st
      || stMaxSuccess st `mod` stMaxGenSize st == 0 =
      ( stNumPassed st
          `mod` stMaxGenSize st
          + stNumDiscarded st `div` 10
      )
        `min` stMaxGenSize st
  | otherwise =
      ( (stNumPassed st `mod` stMaxGenSize st)
          * stMaxGenSize st
          `div` (stMaxSuccess st `mod` stMaxGenSize st)
          + stNumDiscarded st `div` 10
      )
        `min` stMaxGenSize st
  where
    roundTo n m = (n `div` m) * m
