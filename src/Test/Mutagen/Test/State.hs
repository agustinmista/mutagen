{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}

-- | Internal Mutagen testing state and state manipulation functions.
module Test.Mutagen.Test.State
  ( -- * Mutagen internal state
    MutagenState (..)
  , initMutagenState

    -- * State modifiers
  , setExpect
  , setNextSeed
  , setCurrentGenSize
  , setAutoResetAfter
  , setRandomMutations
  , setPassedQueue
  , updatePassedQueue
  , setDiscardedQueue
  , updateDiscardedQueue
  , setFragmentStore
  , updateFragmentStore
  , incNumTraceStoreResets
  , incNumPassed
  , incNumDiscarded
  , incNumFailed
  , incNumGenerated
  , incNumMutatedFromPassed
  , incNumMutatedFromDiscarded
  , incNumInteresting
  , incNumBoring
  , incNumTestsSinceLastInteresting
  , incMutantKindCounter
  , resetNumTestsSinceLastInteresting

    -- * State-related utilities
  , timedOut
  , computeSize
  , nextCounterexamplePath
  )
where

import Data.List (elemIndex)
import Data.Time.Clock.POSIX (POSIXTime, getPOSIXTime)
import System.FilePath ((<.>))
import Test.Mutagen.Config
  ( Config (..)
  , DebugMode (..)
  , LazyPruningMode (..)
  )
import Test.Mutagen.Fragment.Store
  ( FragmentStore
  , FragmentTypeFilter
  , emptyFragmentStore
  , storeFragments
  )
import Test.Mutagen.Mutant (MutantKind (..))
import Test.Mutagen.Mutation (MutationOrder)
import Test.Mutagen.Property (Args (..), Prop, Property (..))
import Test.Mutagen.Test.Queue (MutationQueue, emptyMutationQueue)
import Test.Mutagen.Tracer.Metadata (loadTracerMetadata, numTracingNodes)
import Test.Mutagen.Tracer.Store
  ( STraceBackend
  , TraceStoreImpl (..)
  , withTraceBackend
  )
import Test.QuickCheck.Gen (Gen)
import Test.QuickCheck.Random (QCGen, newQCGen)

{-------------------------------------------------------------------------------
-- * Mutagen internal state
-------------------------------------------------------------------------------}

-- | Internal testing state.
data MutagenState
  = forall trace.
  (TraceStoreImpl trace) =>
  MutagenState
  { stMaxSuccess :: !Int
  -- ^ Mirrored from 'Config.maxSuccess'
  , stMaxDiscardRatio :: !Int
  -- ^ Mirrored from 'Config.maxDiscardRatio'
  , stTimeout :: !(Maybe Integer)
  -- ^ Mirrored from 'Config.timeout'
  , stExpect :: Bool
  -- ^ Mirrored from 'Config.expect'
  , stMaxGenSize :: !Int
  -- ^ Mirrored from 'Config.maxGenSize'
  , stRandomMutations :: !Int
  -- ^ Mirrored from 'Config.randomMutations'
  , stMaxMutationDepth :: !Int
  -- ^ Mirrored from 'Config.maxMutationDepth'
  , stAutoResetAfter :: !(Maybe Int)
  -- ^ Mirrored from 'Config.autoResetAfter'
  , stLazyPruning :: !(LazyPruningMode)
  -- ^ Mirrored from 'Config.lazyPruning'
  , stMutationOrder :: !MutationOrder
  -- ^ Mirrored from 'Config.mutationOrder'
  , stRandomFragments :: !Int
  -- ^ Mirrored from 'Config.randomFragments'
  , stUseFragments :: !Bool
  -- ^ Mirrored from 'Config.useFragments'
  , stFilterFragments :: !FragmentTypeFilter
  -- ^ Mirrored from 'Config.filterFragments'
  , stMaxTraceLength :: !(Maybe Int)
  -- ^ Mirrored from 'Config.maxTraceLength'
  , stKeepGoing :: !Bool
  -- ^ Mirrored from 'Config.keepGoing'
  , stSaveCounterexamples :: !(Maybe FilePath)
  -- ^ Mirrored from 'Config.saveCounterexamples'
  , stChatty :: !Bool
  -- ^ Mirrored from 'Config.chatty'
  , stDebug :: !DebugMode
  -- ^ Mirrored from 'Config.debug'
  , stTui :: !Bool
  -- ^ Mirrored from 'Config.tui'
  , stNextSeed :: !QCGen
  -- ^ Next seed to be when generating random values
  , stArgsGen :: !(Gen Args)
  -- ^ Random generator for test case inputs
  , stPropRunner :: !(Args -> Prop)
  -- ^ Test case runner
  , stNumTracingNodes :: !Int
  -- ^ Number of trace nodes generated by the tracer plugin
  , stTraceBackend :: !(STraceBackend trace)
  -- ^ Tracing type being used
  , stPassedTraceStore :: !(TraceStore trace)
  -- ^ Trace store for passed test cases
  , stDiscardedTraceStore :: !(TraceStore trace)
  -- ^ Trace store for discarded test cases
  , stPassedQueue :: !MutationQueue
  -- ^ Mutation queue derived from passed test cases
  , stDiscardedQueue :: !MutationQueue
  -- ^ Mutation queue derived from discarded test cases
  , stFragmentStore :: !FragmentStore
  -- ^ Stored fragments for fragment-based mutation
  , stStartTime :: !POSIXTime
  -- ^ Timestamp when testing started
  , stCurrentGenSize :: !Int
  -- ^ Size of the current randomly generated test case
  , stNumGenerated :: !Int
  -- ^ Number of generated test cases
  , stNumMutatedFromPassed :: !Int
  -- ^ Number of test cases mutated from passed test cases
  , stNumMutatedFromDiscarded :: !Int
  -- ^ Number of test cases mutated from discarded test cases
  , stNumPureMutants :: !Int
  -- ^ Number of pure mutants generated
  , stNumRandMutants :: !Int
  -- ^ Number of random mutants generated
  , stNumFragMutants :: !Int
  -- ^ Number of fragment mutants generated
  , stNumPassed :: !Int
  -- ^ Number of passed test cases
  , stNumDiscarded :: !Int
  -- ^ Number of discarded test cases
  , stNumFailed :: !Int
  -- ^ Number of failed test cases (only useful when 'keepGoing' is enabled)
  , stNumInteresting :: !Int
  -- ^ Number of interesting test cases
  , stNumBoring :: !Int
  -- ^ Number of boring test cases
  , stNumTestsSinceLastInteresting :: !Int
  -- ^ Number of test cases since the last interesting one
  , stNumTraceStoreResets :: !Int
  -- ^ Number of times the trace store have been reset
  }

-- | Initialize the internal state.
initMutagenState :: Config -> Property -> IO MutagenState
initMutagenState cfg (Property gen runner) = do
  -- Start timestamp
  now <- getPOSIXTime
  -- Initialize random generator
  rng <- newQCGen
  -- Load the metadata generated
  tracingNodes <- numTracingNodes <$> loadTracerMetadata
  -- If enabled, initialize the fragment store using the provided examples
  let fragmentStore
        | useFragments cfg = fragmentStoreFromExamples (examples cfg)
        | otherwise = emptyFragmentStore
  -- Reify the selected trace store implementation
  withTraceBackend (traceBackend cfg) $ \(backend :: STraceBackend trace) -> do
    -- Initialize empty trace stores for passed and discarded test cases
    passedTraceStore <- newTraceStore @trace tracingNodes
    discardedTraceStore <- newTraceStore @trace tracingNodes
    -- Put it all together
    return
      MutagenState
        { -- From config
          stMaxSuccess = maxSuccess cfg
        , stMaxDiscardRatio = maxDiscardRatio cfg
        , stTimeout = timeout cfg
        , stExpect = expect cfg
        , stMaxGenSize = maxGenSize cfg
        , stRandomMutations = randomMutations cfg
        , stRandomFragments = randomFragments cfg
        , stMaxMutationDepth = maybe (maxGenSize cfg) id (maxMutationDepth cfg)
        , stAutoResetAfter = autoResetAfter cfg
        , stLazyPruning = lazyPruning cfg
        , stMutationOrder = mutationOrder cfg
        , stUseFragments = useFragments cfg
        , stFilterFragments = filterFragments cfg
        , stMaxTraceLength = maxTraceLength cfg
        , stKeepGoing = keepGoing cfg
        , stSaveCounterexamples = saveCounterexamples cfg
        , stChatty = chatty cfg || debug cfg /= NoDebug
        , stDebug = debug cfg
        , stTui = tui cfg
        , -- Internal
          stNextSeed = rng
        , stArgsGen = gen
        , stPropRunner = runner
        , stNumTracingNodes = tracingNodes
        , stTraceBackend = backend
        , stPassedTraceStore = passedTraceStore
        , stDiscardedTraceStore = discardedTraceStore
        , stPassedQueue = emptyMutationQueue
        , stDiscardedQueue = emptyMutationQueue
        , stFragmentStore = fragmentStore
        , stStartTime = now
        , stCurrentGenSize = 0
        , stNumGenerated = 0
        , stNumMutatedFromPassed = 0
        , stNumMutatedFromDiscarded = 0
        , stNumPureMutants = 0
        , stNumRandMutants = 0
        , stNumFragMutants = 0
        , stNumPassed = 0
        , stNumFailed = 0
        , stNumDiscarded = 0
        , stNumInteresting = 0
        , stNumBoring = 0
        , stNumTestsSinceLastInteresting = 0
        , stNumTraceStoreResets = 0
        }
  where
    fragmentStoreFromExamples =
      foldr
        (storeFragments (filterFragments cfg))
        emptyFragmentStore

{-------------------------------------------------------------------------------
-- * State modifiers
-------------------------------------------------------------------------------}

-- ** Setters

setExpect :: Bool -> MutagenState -> MutagenState
setExpect val st =
  st{stExpect = val}

setNextSeed :: QCGen -> MutagenState -> MutagenState
setNextSeed val st =
  st{stNextSeed = val}

setCurrentGenSize :: Int -> MutagenState -> MutagenState
setCurrentGenSize val st =
  st{stCurrentGenSize = val}

setAutoResetAfter :: Maybe Int -> MutagenState -> MutagenState
setAutoResetAfter val st =
  st{stAutoResetAfter = val}

setRandomMutations :: Int -> MutagenState -> MutagenState
setRandomMutations val st =
  st{stRandomMutations = val}

setPassedQueue :: MutationQueue -> MutagenState -> MutagenState
setPassedQueue val st =
  st{stPassedQueue = val}

updatePassedQueue :: (MutationQueue -> MutationQueue) -> MutagenState -> MutagenState
updatePassedQueue f st =
  st{stPassedQueue = f (stPassedQueue st)}

setDiscardedQueue :: MutationQueue -> MutagenState -> MutagenState
setDiscardedQueue val st =
  st{stDiscardedQueue = val}

updateDiscardedQueue :: (MutationQueue -> MutationQueue) -> MutagenState -> MutagenState
updateDiscardedQueue f st =
  st{stDiscardedQueue = f (stDiscardedQueue st)}

setFragmentStore :: FragmentStore -> MutagenState -> MutagenState
setFragmentStore val st =
  st{stFragmentStore = val}

updateFragmentStore :: (FragmentStore -> FragmentStore) -> MutagenState -> MutagenState
updateFragmentStore f st =
  st{stFragmentStore = f (stFragmentStore st)}

-- ** Incrementers

incNumTraceStoreResets :: MutagenState -> MutagenState
incNumTraceStoreResets st =
  st{stNumTraceStoreResets = stNumTraceStoreResets st + 1}

incNumPassed :: MutagenState -> MutagenState
incNumPassed st =
  st{stNumPassed = stNumPassed st + 1}

incNumDiscarded :: MutagenState -> MutagenState
incNumDiscarded st =
  st{stNumDiscarded = stNumDiscarded st + 1}

incNumFailed :: MutagenState -> MutagenState
incNumFailed st =
  st{stNumFailed = stNumFailed st + 1}

incNumGenerated :: MutagenState -> MutagenState
incNumGenerated st =
  st{stNumGenerated = stNumGenerated st + 1}

incNumMutatedFromPassed :: MutagenState -> MutagenState
incNumMutatedFromPassed st =
  st{stNumMutatedFromPassed = stNumMutatedFromPassed st + 1}

incNumMutatedFromDiscarded :: MutagenState -> MutagenState
incNumMutatedFromDiscarded st =
  st{stNumMutatedFromDiscarded = stNumMutatedFromDiscarded st + 1}

incNumInteresting :: MutagenState -> MutagenState
incNumInteresting st =
  st{stNumInteresting = stNumInteresting st + 1}

incNumBoring :: MutagenState -> MutagenState
incNumBoring st =
  st{stNumBoring = stNumBoring st + 1}

incNumTestsSinceLastInteresting :: MutagenState -> MutagenState
incNumTestsSinceLastInteresting st =
  st{stNumTestsSinceLastInteresting = stNumTestsSinceLastInteresting st + 1}

incMutantKindCounter :: MutantKind -> MutagenState -> MutagenState
incMutantKindCounter kind st =
  case kind of
    PureMutant -> st{stNumPureMutants = stNumPureMutants st + 1}
    RandMutant -> st{stNumRandMutants = stNumRandMutants st + 1}
    FragMutant -> st{stNumFragMutants = stNumFragMutants st + 1}

-- ** Resetters

resetNumTestsSinceLastInteresting :: MutagenState -> MutagenState
resetNumTestsSinceLastInteresting st =
  st{stNumTestsSinceLastInteresting = 0}

{-------------------------------------------------------------------------------
-- * State-related utilities
-------------------------------------------------------------------------------}

-- | Check whether the timeout has passed.
timedOut :: MutagenState -> IO Bool
timedOut st
  | Just s <- stTimeout st = do
      now <- getPOSIXTime
      return (now >= stStartTime st + (fromIntegral s))
  | otherwise = return False

-- | Compute the size of the next randomly generated value.
--
-- NOTE: This function mimics QuickCheck's size computation strategy.
computeSize :: MutagenState -> Int
computeSize st
  | stNumPassed st `roundTo` stMaxGenSize st + stMaxGenSize st <= stMaxSuccess st
      || stNumPassed st >= stMaxSuccess st
      || stMaxSuccess st `mod` stMaxGenSize st == 0 =
      ( stNumPassed st
          `mod` stMaxGenSize st
          + stNumDiscarded st `div` 10
      )
        `min` stMaxGenSize st
  | otherwise =
      ( (stNumPassed st `mod` stMaxGenSize st)
          * stMaxGenSize st
          `div` (stMaxSuccess st `mod` stMaxGenSize st)
          + stNumDiscarded st `div` 10
      )
        `min` stMaxGenSize st
  where
    roundTo n m = (n `div` m) * m

-- | Compute the path for the next counterexample to be saved.
--
-- If no counterexamples are to be saved, returns 'Nothing'. If a path template
-- is provided (containing @\@@), replaces @\@@ with the current failure
-- counter. Otherwise, appends the counter to the given path.
nextCounterexamplePath :: MutagenState -> Maybe FilePath
nextCounterexamplePath st
  | Just path <- stSaveCounterexamples st =
      case elemIndex '@' path of
        Just n -> Just (replace n (show (stNumFailed st)) path)
        Nothing -> Just (path <.> show (stNumFailed st))
  | otherwise = Nothing
  where
    replace n s str =
      let (before, after) = splitAt n str in before <> s <> drop 1 after
