{-# LANGUAGE ExistentialQuantification #-}
{-# LANGUAGE RankNTypes #-}
{-# LANGUAGE ScopedTypeVariables #-}
{-# LANGUAGE TypeApplications #-}

module Test.Mutagen.Test.State
  ( -- * Mutagen internal state
    MutagenState (..)
  , initMutagenState

    -- * State modifiers
  , setNextSeed
  , setCurrentGenSize
  , setAutoResetAfter
  , setRandomMutations
  , setPassedQueue
  , setDiscardedQueue
  , setFragmentStore
  , increaseNumTraceLogResets
  , increaseNumPassed
  , increaseNumDiscarded
  , increaseNumGenerated
  , increaseNumMutatedFromPassed
  , increaseNumMutatedFromDiscarded
  , increaseNumInteresting
  , increaseNumBoring
  , increaseNumTestsSinceLastInteresting
  , increaseMutantKindCounter
  , resetNumTestsSinceLastInteresting

    -- * Mutation priority queues
  , MutationQueue
  , createOrInheritMutationBatch

    -- * State-related utilities
  , passedTimeout
  , computeSize
  )
where

import Data.PQueue.Prio.Min (MinPQueue)
import Data.Time.Clock.POSIX
import Data.Typeable
import Test.Mutagen.Fragment
import Test.Mutagen.Mutant
import Test.Mutagen.Mutation
import Test.Mutagen.Property
import Test.Mutagen.Test.Batch
import Test.Mutagen.Test.Config
import Test.Mutagen.Tracer.Metadata
import Test.Mutagen.Tracer.Store
  ( STraceType
  , TraceStoreImpl (..)
  , withTraceType
  )
import Test.Mutagen.Tracer.Trace
import Test.QuickCheck.Gen (Gen)
import Test.QuickCheck.Random (QCGen, newQCGen)

{-------------------------------------------------------------------------------
-- * Mutagen internal state
-------------------------------------------------------------------------------}

-- | Testing state (internal)
data MutagenState
  = forall trace.
  (TraceStoreImpl trace) =>
  MutagenState
  ----------------------------------------
  -- Mirrored from Config
  { stMaxSuccess :: !Int
  , stMaxDiscardRatio :: !Int
  , stTimeout :: !(Maybe Integer)
  , stMaxGenSize :: !Int
  , stRandomMutations :: !Int
  , stMutationLimit :: !Int
  , stAutoResetAfter :: !(Maybe Int)
  , stUseLazyPrunning :: !Bool
  , stMutationOrder :: !MutationOrder
  , stRandomFragments :: !Int
  , stUseFragments :: !Bool
  , stFilterFragments :: !(Maybe [TypeRep])
  , stMaxTraceLength :: !(Maybe Int)
  , stChatty :: !Bool
  , stDebug :: !Bool
  , ----------------------------------------
    -- Test case generation
    stNextSeed :: !QCGen
  -- ^ The next seed to be used by `stArgsGen`
  , stArgsGen :: !(Gen Args)
  -- ^ The random generator of inputs
  , ----------------------------------------
    -- Property runner
    stArgsRunner :: !(Args -> Result)
  , stExpect :: Bool
  -- ^ Whether we expect the property to hold or not
  , ----------------------------------------
    -- Trace logs
    stGeneratedTraceNodes :: !Int
  , stTraceType :: !(STraceType trace)
  , stPassedTraceLog :: !(TraceStore trace)
  , stDiscardedTraceLog :: !(TraceStore trace)
  , ----------------------------------------
    -- Mutation queues
    stPassedQueue :: !MutationQueue
  , stDiscardedQueue :: !MutationQueue
  , ----------------------------------------
    -- Global fragment store
    stFragmentStore :: !FragmentStore
  , ----------------------------------------
    -- Statistics
    stStartTime :: !Integer
  , stCurrentGenSize :: !Int
  , stNumGenerated :: !Int
  , stNumMutatedFromPassed :: !Int
  , stNumMutatedFromDiscarded :: !Int
  , stNumPureMutants :: !Int
  , stNumRandMutants :: !Int
  , stNumFragMutants :: !Int
  , stNumPassed :: !Int
  , stNumDiscarded :: !Int
  , stNumInteresting :: !Int
  , stNumBoring :: !Int
  , stNumTestsSinceLastInteresting :: !Int
  , stNumTraceLogResets :: !Int
  }

initMutagenState :: Config -> Property -> IO MutagenState
initMutagenState cfg (Property gen argsRunner) = do
  -- rng generator
  rng <- newQCGen
  -- start timestamp
  now <- round <$> getPOSIXTime
  -- read the amount of trace nodes generated by the plugin
  traceNodes <- numTracingNodes <$> loadTracerMetadata
  -- fragmentize the initial example seeds
  let initialFragmentStore =
        if useFragments cfg
          then foldr (storeFragments (filterFragments cfg)) emptyFragmentStore (examples cfg)
          else emptyFragmentStore
  -- create empty trace logs for passed and discarded test cases
  withTraceType (traceType cfg) $ \(sTraceType :: STraceType trace) -> do
    passedTraceStore <- newTraceStore @trace traceNodes
    discardedTraceStore <- newTraceStore @trace traceNodes

    -- build the initial state
    return
      MutagenState
        { -- From config
          stMaxSuccess = maxSuccess cfg
        , stMaxDiscardRatio = maxDiscardRatio cfg
        , stTimeout = timeout cfg
        , stMaxGenSize = maxGenSize cfg
        , stRandomMutations = randomMutations cfg
        , stRandomFragments = randomFragments cfg
        , stMutationLimit = maybe (maxGenSize cfg) id (mutationLimit cfg)
        , stAutoResetAfter = autoResetAfter cfg
        , stUseLazyPrunning = useLazyPrunning cfg
        , stMutationOrder = mutationOrder cfg
        , stUseFragments = useFragments cfg
        , stFilterFragments = filterFragments cfg
        , stMaxTraceLength = maxTraceLength cfg
        , stChatty = chatty cfg || debug cfg
        , stDebug = debug cfg
        , -- Internal
          stNextSeed = rng
        , stArgsGen = gen
        , stArgsRunner = argsRunner
        , stExpect = True -- properties should hold unless wrapped in `expectFailure`
        , stGeneratedTraceNodes = traceNodes
        , stTraceType = sTraceType
        , stPassedTraceLog = passedTraceStore
        , stDiscardedTraceLog = discardedTraceStore
        , stPassedQueue = mempty
        , stDiscardedQueue = mempty
        , stFragmentStore = initialFragmentStore
        , stStartTime = now
        , stCurrentGenSize = 0
        , stNumGenerated = 0
        , stNumMutatedFromPassed = 0
        , stNumMutatedFromDiscarded = 0
        , stNumPureMutants = 0
        , stNumRandMutants = 0
        , stNumFragMutants = 0
        , stNumPassed = 0
        , stNumDiscarded = 0
        , stNumInteresting = 0
        , stNumBoring = 0
        , stNumTestsSinceLastInteresting = 0
        , stNumTraceLogResets = 0
        }

----------------------------------------
-- State modifiers

setNextSeed :: QCGen -> MutagenState -> MutagenState
setNextSeed val st = st{stNextSeed = val}

setCurrentGenSize :: Int -> MutagenState -> MutagenState
setCurrentGenSize val st = st{stCurrentGenSize = val}

setAutoResetAfter :: Maybe Int -> MutagenState -> MutagenState
setAutoResetAfter val st = st{stAutoResetAfter = val}

setRandomMutations :: Int -> MutagenState -> MutagenState
setRandomMutations val st = st{stRandomMutations = val}

setPassedQueue :: MutationQueue -> MutagenState -> MutagenState
setPassedQueue val st = st{stPassedQueue = val}

setDiscardedQueue :: MutationQueue -> MutagenState -> MutagenState
setDiscardedQueue val st = st{stDiscardedQueue = val}

setFragmentStore :: FragmentStore -> MutagenState -> MutagenState
setFragmentStore val st = st{stFragmentStore = val}

increaseNumTraceLogResets :: MutagenState -> MutagenState
increaseNumTraceLogResets st = st{stNumTraceLogResets = stNumTraceLogResets st + 1}

increaseNumPassed :: MutagenState -> MutagenState
increaseNumPassed st = st{stNumPassed = stNumPassed st + 1}

increaseNumDiscarded :: MutagenState -> MutagenState
increaseNumDiscarded st = st{stNumDiscarded = stNumDiscarded st + 1}

increaseNumGenerated :: MutagenState -> MutagenState
increaseNumGenerated st = st{stNumGenerated = stNumGenerated st + 1}

increaseNumMutatedFromPassed :: MutagenState -> MutagenState
increaseNumMutatedFromPassed st = st{stNumMutatedFromPassed = stNumMutatedFromPassed st + 1}

increaseNumMutatedFromDiscarded :: MutagenState -> MutagenState
increaseNumMutatedFromDiscarded st = st{stNumMutatedFromDiscarded = stNumMutatedFromDiscarded st + 1}

increaseNumInteresting :: MutagenState -> MutagenState
increaseNumInteresting st = st{stNumInteresting = stNumInteresting st + 1}

increaseNumBoring :: MutagenState -> MutagenState
increaseNumBoring st = st{stNumBoring = stNumBoring st + 1}

increaseNumTestsSinceLastInteresting :: MutagenState -> MutagenState
increaseNumTestsSinceLastInteresting st = st{stNumTestsSinceLastInteresting = stNumTestsSinceLastInteresting st + 1}

increaseMutantKindCounter :: MutantKind -> MutagenState -> MutagenState
increaseMutantKindCounter PureMutant st = st{stNumPureMutants = stNumPureMutants st + 1}
increaseMutantKindCounter RandMutant st = st{stNumRandMutants = stNumRandMutants st + 1}
increaseMutantKindCounter FragMutant st = st{stNumFragMutants = stNumFragMutants st + 1}

resetNumTestsSinceLastInteresting :: MutagenState -> MutagenState
resetNumTestsSinceLastInteresting st = st{stNumTestsSinceLastInteresting = 0}

----------------------------------------
-- Mutation priority queues

-- Mutation candidates
type MutationQueue =
  MinPQueue
    Int -- The candidate priority
    ( Args -- The test case inputs
    , Trace -- The code coverage it triggered
    , MutationBatch Args -- The batch of possible mutations
    )

-- Inherit the mutation batch of a parent test case of it exists, otherwise create a new one.
createOrInheritMutationBatch :: MutagenState -> Args -> Maybe (MutationBatch Args) -> Maybe [Pos] -> Bool -> MutationBatch Args
createOrInheritMutationBatch st args parentbatch pos isPassed =
  case parentbatch of
    -- test case was mutated from an existing one, we can augment its parent mutation batch
    Just mb ->
      newMutationBatchFromParent
        mb
        pos
        isPassed
        args
    -- test case was freshly generated, we need to initialize a new mutation batch
    Nothing ->
      newMutationBatch
        (stMutationOrder st)
        (stRandomMutations st)
        (stMaxGenSize st)
        (stRandomFragments st)
        (stMutationLimit st)
        pos
        isPassed
        args

----------------------------------------
-- State-related utilities

-- Check whether the timeout has passed
passedTimeout :: MutagenState -> IO Bool
passedTimeout st
  | Just s <- stTimeout st = do
      now <- round <$> getPOSIXTime
      return (now >= stStartTime st + s)
  | otherwise = return False

-- Compute the size of the next randomly generated value
computeSize :: MutagenState -> Int
computeSize st
  | stNumPassed st `roundTo` stMaxGenSize st + stMaxGenSize st <= stMaxSuccess st
      || stNumPassed st >= stMaxSuccess st
      || stMaxSuccess st `mod` stMaxGenSize st == 0 =
      (stNumPassed st `mod` stMaxGenSize st + stNumDiscarded st `div` 10) `min` stMaxGenSize st
  | otherwise =
      ( (stNumPassed st `mod` stMaxGenSize st)
          * stMaxGenSize st
          `div` (stMaxSuccess st `mod` stMaxGenSize st)
          + stNumDiscarded st `div` 10
      )
        `min` stMaxGenSize st

roundTo :: (Integral a) => a -> a -> a
roundTo n m = (n `div` m) * m
